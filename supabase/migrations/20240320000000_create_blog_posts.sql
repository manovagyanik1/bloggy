-- Clean up existing objects
DROP TRIGGER IF EXISTS set_blog_posts_updated_at ON blog_posts;
DROP TRIGGER IF EXISTS update_blog_posts_updated_at ON blog_posts;
DROP TABLE IF EXISTS blog_posts CASCADE;

-- Create updated_at function if it doesn't exist
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Create blog_posts table
CREATE TABLE blog_posts (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  project_id UUID NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
  author_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  content TEXT NOT NULL,
  seo_metadata JSONB NOT NULL DEFAULT '{}',
  slug TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add table comment
COMMENT ON TABLE blog_posts IS 'Stores blog posts generated by the AI blog generator';

-- Add indexes
CREATE INDEX blog_posts_project_id_idx ON blog_posts(project_id);
CREATE INDEX blog_posts_author_id_idx ON blog_posts(author_id);
CREATE INDEX blog_posts_created_at_idx ON blog_posts(created_at);
CREATE UNIQUE INDEX blog_posts_project_slug_idx ON blog_posts(project_id, slug);

-- Add updated_at trigger
CREATE TRIGGER set_blog_posts_updated_at
  BEFORE UPDATE ON blog_posts
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- Enable RLS
ALTER TABLE blog_posts ENABLE ROW LEVEL SECURITY;

-- Create RLS policies

CREATE POLICY "Users can insert their own blog posts" ON blog_posts
  FOR INSERT WITH CHECK (
    author_id = auth.uid()
  );

CREATE POLICY "Users can update their own blog posts" ON blog_posts
  FOR UPDATE USING (
    author_id = auth.uid()
  );

CREATE POLICY "Users can delete their own blog posts" ON blog_posts
  FOR DELETE USING (
    author_id = auth.uid()
  ); 